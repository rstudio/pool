[{"path":"http://rstudio.github.io/pool/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 pool authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"http://rstudio.github.io/pool/articles/advanced-pool.html","id":"customizing-your-pool","dir":"Articles","previous_headings":"","what":"Customizing your pool","title":"Advanced usage","text":"First, let’s get know Pool object: can see, printing gives basic information pool. can useful learn many connections open (free/idle use). section, let’s turn attention parameters can pass dbPool(): minSize, maxSize, idleTimeout. created, pool initialize minSize connections, keeps around ’re requested. idle connections taken another request connection comes , pool create new connection. ’ll keep needed gets maxSize connections point error. connection created ’re minSize timer attached : moment returned back pool, countdown idleTimeout seconds start. connection requested period, destroyed countdown finishes. requested checked pool, countdown reset returned back pool. optimal values three parameters depend ’re using pool, represent tradeoff adaptable pool efficient . Large values three parameters mean pool highly adaptable (can handle spikes traffic easily), potentially efficient (might creating holding connections aren’t needed). hand, small values parameters mean pool strict number connections (rarely allow idle connections) lead efficient pool traffic consistent. However, type pool won’t able handle spikes traffic easily: one hand, often computationally expensive fetching connections directly database, since doesn’t hold idle connections long; hand, hits maxSize number connections, won’t able scale . Considering pool falls spectrum, choose value arguments accordingly. example, want stable pool adapt scale easily (’re worried efficiency), something like:","code":"library(pool)  pool <- dbPool(   drv = RMySQL::MySQL(),   dbname = \"shinydemo\",   host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",   username = \"guest\",   password = \"guest\" ) pool #> <Pool> of MySQLConnection objects #>   Objects checked out: 0 #>   Available in pool: 1 #>   Max size: Inf #>   Valid: TRUE library(DBI) library(pool)  pool <- dbPool(   drv = RMySQL::MySQL(),   dbname = \"shinydemo\",   host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",   username = \"guest\",   password = \"guest\",   minSize = 10,   idleTimeout = 60 * 60 )  poolClose(pool)"},{"path":"http://rstudio.github.io/pool/articles/advanced-pool.html","id":"transactions","dir":"Articles","previous_headings":"","what":"Transactions","title":"Advanced usage","text":"far, ’ve recommended always use pool object directly need query database. ’s one challenge possible: transactions. transaction, need access connection longer single query. following necessary work pool might give different connection DBI provides helper case, doesn’t work either: can instead use pool::poolWithTransaction():","code":"dbBegin(pool) dbExecute(pool, A) dbGetQuery(pool, B) dbCommit(pool) DBI::dbWithTransaction(pool, {   dbExecute(pool, A)   dbGetQuery(pool, B) }) pool::poolWithTransaction(pool, function(con) {   dbGetQuery(con, A)   dbGetQuery(con, B) })"},{"path":"http://rstudio.github.io/pool/articles/pool-dplyr.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"Using pool with dplyr","text":"purposes article ’m going start creating simple -memory SQLite database. makes easy show real code difference ’ll use details database connection. First, let’s consider might connect use simple database just dplyr: Now, let’s thing using pool: usually, need change DBI::dbConnect() pool::dbPool(), pool take care rest!","code":"path <- tempfile() con <- DBI::dbConnect(RSQLite::SQLite(), dbname = path) DBI::dbWriteTable(con, \"mtcars\", mtcars) library(dplyr, warn.conflicts = FALSE)  con <- DBI::dbConnect(RSQLite::SQLite(), dbname = path) mtcars_db <- con %>% tbl(\"mtcars\")  mtcars_db %>%    filter(cyl == 8) %>%    head() #> # Source:   SQL [6 x 11] #> # Database: sqlite 3.40.0 [/tmp/RtmpBCwqGz/file18ba64baf70c] #>     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb #>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2 #> 2  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4 #> 3  16.4     8  276.   180  3.07  4.07  17.4     0     0     3     3 #> 4  17.3     8  276.   180  3.07  3.73  17.6     0     0     3     3 #> 5  15.2     8  276.   180  3.07  3.78  18       0     0     3     3 #> 6  10.4     8  472    205  2.93  5.25  18.0     0     0     3     4 con <- pool::dbPool(RSQLite::SQLite(), dbname = path) mtcars_db <- con %>% tbl(\"mtcars\")  mtcars_db %>%    filter(cyl == 8) %>%    head() #> # Source:   SQL [6 x 11] #> # Database: sqlite 3.40.0 [/tmp/RtmpBCwqGz/file18ba64baf70c] #>     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb #>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2 #> 2  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4 #> 3  16.4     8  276.   180  3.07  4.07  17.4     0     0     3     3 #> 4  17.3     8  276.   180  3.07  3.73  17.6     0     0     3     3 #> 5  15.2     8  276.   180  3.07  3.78  18       0     0     3     3 #> 6  10.4     8  472    205  2.93  5.25  18.0     0     0     3     4"},{"path":"http://rstudio.github.io/pool/articles/pool-dplyr.html","id":"shiny-apps","dir":"Articles","previous_headings":"Getting started","what":"Shiny apps","title":"Using pool with dplyr","text":"Now lets show action shiny app: ’s one important tool note: dbplyr::local(). tells dbplyr run input$cyl locally (retrieving value user typed), rather trying convert SQL. Note need input sanitizing SQL injection prevention (.e. need call function like DBI::sqlInterpolate()) dbplyr takes care .","code":"library(shiny) library(dplyr, warn.conflicts = FALSE)  pool <- pool::dbPool(RSQLite::SQLite(), dbname = path) onStop(function() {   pool::poolClose(pool) })  ui <- fluidPage(   textInput(\"cyl\", \"Enter number of cylinders:\", \"6\"),   numericInput(\"nrows\", \"How many rows to show?\", 10),   tableOutput(\"tbl\") )  server <- function(input, output, session) {   output$tbl <- renderTable({     pool %>%        tbl(\"mtcars\") %>%       filter(cyl == local(input$cyl)) %>%        head(input$nrows)   }) }  if (interactive())   shinyApp(ui, server)"},{"path":"http://rstudio.github.io/pool/articles/why-pool.html","id":"one-connection-per-app","dir":"Articles","previous_headings":"","what":"One connection per app","title":"Why pool?","text":"first extreme one connection per app: approach fast, ever create one connection, serious drawbacks: Since one connection, work well multi-user apps. connection breaks point (maybe database timed-), won’t get new connection ’ll restart app). Even ’re making queries moment (.e. leave app running ’re gone), ’ll idle connection sitting around reason.","code":"library(shiny) library(DBI)  # In a multi-file app, you could create conn at the top of your  # server.R file or in global.R conn <- DBI::dbConnect(   drv = RMySQL::MySQL(),   dbname = \"shinydemo\",   host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",   username = \"guest\",   password = \"guest\" ) onStop(function() {   DBI::dbDisconnect(conn) })  ui <- fluidPage(   textInput(\"ID\", \"Enter your ID:\", \"5\"),   tableOutput(\"tbl\"),   numericInput(\"nrows\", \"How many cities to show?\", 10),   plotOutput(\"popPlot\") )  server <- function(input, output, session) {   output$tbl <- renderTable({     sql <- \"SELECT * FROM City WHERE ID = ?id;\"     query <- sqlInterpolate(conn, sql, id = input$ID)     dbGetQuery(conn, query)   })   output$popPlot <- renderPlot({     sql <- \"SELECT * FROM City LIMIT ?id;\"     query <- sqlInterpolate(conn, sql, id = input$nrows)     df <- dbGetQuery(conn, query)     pop <- df$Population     names(pop) <- df$Name     barplot(pop)   }) }  if (interactive())   shinyApp(ui, server)"},{"path":"http://rstudio.github.io/pool/articles/why-pool.html","id":"one-connection-per-query","dir":"Articles","previous_headings":"","what":"One connection per query","title":"Why pool?","text":"Let’s now turn attention extreme: opening closing connection query: advantages approach reverse disadvantages first approach: can handle simultaneous requests, always processed different connections. connection breaks, ’s big deal ’ll just create new one next reactive computation. connection open duration query makes, idle connections sitting around. ’s moderately easy keep track connections (long pair connect dbDisconnect()). hand, less well things former approach excelled : ’s slow: time change input, create connection recalculate reactive. need lot boilerplate code connect disconnect connection within reactive.","code":"library(shiny) library(DBI)  connect <- function() {   DBI::dbConnect(     drv = RMySQL::MySQL(),     dbname = \"shinydemo\",     host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",     username = \"guest\",     password = \"guest\"   ) }  ui <- fluidPage(   textInput(\"ID\", \"Enter your ID:\", \"5\"),   tableOutput(\"tbl\"),   numericInput(\"nrows\", \"How many cities to show?\", 10),   plotOutput(\"popPlot\") )  server <- function(input, output, session) {   output$tbl <- renderTable({     conn <- connect()     on.exit(DBI::dbDisconnect(conn))      sql <- \"SELECT * FROM City WHERE ID = ?id;\"     query <- sqlInterpolate(conn, sql, id = input$ID)     dbGetQuery(conn, query)   })    output$popPlot <- renderPlot({     conn <- connect()     on.exit(DBI::dbDisconnect(conn))      sql <- \"SELECT * FROM City LIMIT ?id;\"     query <- sqlInterpolate(conn, sql, id = input$nrows)     df <- dbGetQuery(conn, query)     pop <- df$Population     names(pop) <- df$Name     barplot(pop)   }) }  if (interactive())   shinyApp(ui, server)"},{"path":"http://rstudio.github.io/pool/articles/why-pool.html","id":"pool-the-best-of-both-worlds","dir":"Articles","previous_headings":"","what":"Pool: the best of both worlds","title":"Why pool?","text":"Wouldn’t nice combine advantages two approaches? ’s exactly goal pool! connection pool abstracts away logic connection management, , vast majority cases, never deal connections directly. Since pool knows needs connections open close , creates demand can share existing connections already created. code just simple connection per app approach: need substitute pool::dbPool() DBI::dbConnect() pool::poolClose() DBI::dbDisconnect(). default, pool maintain one idle connection. make query pool, always use connection, unless happens already busy. case, pool create another connection, use , return pool. second connection isn’t used minute (default), pool disconnect .","code":"library(shiny) library(DBI)  pool <- pool::dbPool(   drv = RMySQL::MySQL(),   dbname = \"shinydemo\",   host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",   username = \"guest\",   password = \"guest\" ) onStop(function() {   pool::poolClose(pool) })  ui <- fluidPage(   textInput(\"ID\", \"Enter your ID:\", \"5\"),   tableOutput(\"tbl\"),   numericInput(\"nrows\", \"How many cities to show?\", 10),   plotOutput(\"popPlot\") )  server <- function(input, output, session) {   output$tbl <- renderTable({     sql <- \"SELECT * FROM City WHERE ID = ?id;\"     query <- sqlInterpolate(pool, sql, id = input$ID)     dbGetQuery(pool, query)   })      output$popPlot <- renderPlot({     sql <- \"SELECT * FROM City LIMIT ?id;\"     query <- sqlInterpolate(conn, sql, id = input$nrows)     df <- dbGetQuery(pool, query)     pop <- df$Population     names(pop) <- df$Name     barplot(pop)   }) }  if (interactive())   shinyApp(ui, server)"},{"path":"http://rstudio.github.io/pool/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Joe Cheng. Author. Barbara Borges. Author. Hadley Wickham. Author, maintainer. . Copyright holder, funder.","code":""},{"path":"http://rstudio.github.io/pool/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Cheng J, Borges B, Wickham H (2023). pool: Object Pooling. https://github.com/rstudio/pool, http://rstudio.github.io/pool/.","code":"@Manual{,   title = {pool: Object Pooling},   author = {Joe Cheng and Barbara Borges and Hadley Wickham},   year = {2023},   note = {https://github.com/rstudio/pool, http://rstudio.github.io/pool/}, }"},{"path":"http://rstudio.github.io/pool/index.html","id":"pool","dir":"","previous_headings":"","what":"Object Pooling","title":"Object Pooling","text":"goal pool package abstract away challenges database connection management, particularly relevant interactive contexts like Shiny apps connect database. Instead creating close connections , create “pool” connections, pool package manages . never create close connections directly: pool knows grow, shrink keep steady. need close pool ’re done. pool works seamlessly DBI dplyr, cases using pool package simple replacing DBI::dbConnect() dbPool() adding call poolClose(). Learn pool needed vignette(\"-pool\"). (pool package actually general enough allow construct pool kind object, just database connections, database connections currently ’s primary claim fame.)","code":""},{"path":"http://rstudio.github.io/pool/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Object Pooling","text":"’s simple example using pool within Shiny app (feel free try ): Note: loadNamespace(\"dbplyr\") line help rsconnect package deploying application shinyapps.io Posit Connect. Without line, rsconnect detect dbplyr package needed, application work properly.","code":"library(shiny) library(dplyr) library(pool) loadNamespace(\"dbplyr\")  pool <- dbPool(   drv = RMySQL::MySQL(),   dbname = \"shinydemo\",   host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",   username = \"guest\",   password = \"guest\" ) onStop(function() {   poolClose(pool) })  ui <- fluidPage(   textInput(\"ID\", \"Enter your ID:\", \"5\"),   tableOutput(\"tbl\"),   numericInput(\"nrows\", \"How many cities to show?\", 10),   plotOutput(\"popPlot\") )  server <- function(input, output, session) {   city <- tbl(pool, \"City\")    output$tbl <- renderTable({     city |> filter(ID == !!input$ID) |> collect()   })   output$popPlot <- renderPlot({     df <- city |> head(input$nrows) |> collect()      pop <- df |> pull(\"Population\", name = \"Name\")     barplot(pop)   }) }  shinyApp(ui, server)"},{"path":"http://rstudio.github.io/pool/reference/DBI-custom.html","id":null,"dir":"Reference","previous_headings":"","what":"Unsupported DBI methods — DBI-custom","title":"Unsupported DBI methods — DBI-custom","text":"pool methods DBI generics check connection, perform operation, return connection pool, described DBI-wrap. page describes exceptions: DBI::dbSendQuery() DBI::dbSendStatement() work pool return result sets bound specific connection. Instead use DBI::dbGetQuery(), DBI::dbExecute(), localCheckout(). DBI::dbBegin(), DBI::dbRollback(), DBI::dbCommit(), DBI::dbWithTransaction() work pool transactions bound connection. Instead use poolWithTransaction(). DBI::dbDisconnect() work pool handles disconnection. DBI::dbGetInfo() returns information pool, database connection. DBI::dbIsValid() returns whether entire pool valid (.e. closed).","code":""},{"path":"http://rstudio.github.io/pool/reference/DBI-custom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unsupported DBI methods — DBI-custom","text":"","code":"# S4 method for Pool dbSendQuery(conn, statement, ...)  # S4 method for Pool,ANY dbSendStatement(conn, statement, ...)  # S4 method for Pool dbDisconnect(conn, ...)  # S4 method for Pool dbGetInfo(dbObj, ...)  # S4 method for Pool dbIsValid(dbObj, ...)  # S4 method for Pool dbBegin(conn, ...)  # S4 method for Pool dbCommit(conn, ...)  # S4 method for Pool dbRollback(conn, ...)  # S4 method for Pool dbWithTransaction(conn, code)"},{"path":"http://rstudio.github.io/pool/reference/DBI-custom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unsupported DBI methods — DBI-custom","text":"conn, dbObj Pool object, returned dbPool(). statement, code, ... See DBI documentation.","code":""},{"path":"http://rstudio.github.io/pool/reference/DBI-wrap.html","id":null,"dir":"Reference","previous_headings":"","what":"DBI methods (simple wrappers) — DBI-wrap","title":"DBI methods (simple wrappers) — DBI-wrap","text":"pool method DBI generics methods check connection (poolCheckout()), re-call generic, return connection pool (poolReturn()).","code":""},{"path":"http://rstudio.github.io/pool/reference/DBI-wrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DBI methods (simple wrappers) — DBI-wrap","text":"","code":"# S4 method for Pool dbDataType(dbObj, obj, ...)  # S4 method for Pool,ANY dbGetQuery(conn, statement, ...)  # S4 method for Pool,ANY dbExecute(conn, statement, ...)  # S4 method for Pool,ANY dbListFields(conn, name, ...)  # S4 method for Pool dbListTables(conn, ...)  # S4 method for Pool dbListObjects(conn, prefix = NULL, ...)  # S4 method for Pool,ANY dbReadTable(conn, name, ...)  # S4 method for Pool,ANY dbWriteTable(conn, name, value, ...)  # S4 method for Pool dbCreateTable(conn, name, fields, ..., row.names = NULL, temporary = FALSE)  # S4 method for Pool dbAppendTable(conn, name, value, ..., row.names = NULL)  # S4 method for Pool,ANY dbExistsTable(conn, name, ...)  # S4 method for Pool,ANY dbRemoveTable(conn, name, ...)  # S4 method for Pool dbIsReadOnly(dbObj, ...)  # S4 method for Pool sqlData(con, value, row.names = NA, ...)  # S4 method for Pool sqlCreateTable(con, table, fields, row.names = NA, temporary = FALSE, ...)  # S4 method for Pool sqlAppendTable(con, table, values, row.names = NA, ...)  # S4 method for Pool sqlInterpolate(conn, sql, ..., .dots = list())  # S4 method for Pool sqlParseVariables(conn, sql, ...)  # S4 method for Pool,ANY dbQuoteIdentifier(conn, x, ...)  # S4 method for Pool dbUnquoteIdentifier(conn, x, ...)  # S4 method for Pool dbQuoteLiteral(conn, x, ...)  # S4 method for Pool,ANY dbQuoteString(conn, x, ...)"},{"path":"http://rstudio.github.io/pool/reference/DBI-wrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DBI methods (simple wrappers) — DBI-wrap","text":"","code":"mtcars1 <- mtcars[ c(1:16), ] # first half of the mtcars dataset mtcars2 <- mtcars[-c(1:16), ] # second half of the mtcars dataset  pool <- dbPool(RSQLite::SQLite())  # write the mtcars1 table into the database dbWriteTable(pool, \"mtcars\", mtcars1, row.names = TRUE)  # list the current tables in the database dbListTables(pool) #> [1] \"mtcars\"  # read the \"mtcars\" table from the database (only 16 rows) dbReadTable(pool, \"mtcars\") #>              row_names  mpg cyl  disp  hp drat    wt  qsec vs am gear #> 1            Mazda RX4 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4 #> 2        Mazda RX4 Wag 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4 #> 3           Datsun 710 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4 #> 4       Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3 #> 5    Hornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3 #> 6              Valiant 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3 #> 7           Duster 360 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3 #> 8            Merc 240D 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4 #> 9             Merc 230 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4 #> 10            Merc 280 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4 #> 11           Merc 280C 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4 #> 12          Merc 450SE 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3 #> 13          Merc 450SL 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3 #> 14         Merc 450SLC 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3 #> 15  Cadillac Fleetwood 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3 #> 16 Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3 #>    carb #> 1     4 #> 2     4 #> 3     1 #> 4     1 #> 5     2 #> 6     1 #> 7     4 #> 8     2 #> 9     2 #> 10    4 #> 11    4 #> 12    3 #> 13    3 #> 14    3 #> 15    4 #> 16    4  # append mtcars2 to the \"mtcars\" table already in the database dbWriteTable(pool, \"mtcars\", mtcars2, row.names = TRUE, append = TRUE)  # read the \"mtcars\" table from the database (all 32 rows) dbReadTable(pool, \"mtcars\") #>              row_names  mpg cyl  disp  hp drat    wt  qsec vs am gear #> 1            Mazda RX4 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4 #> 2        Mazda RX4 Wag 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4 #> 3           Datsun 710 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4 #> 4       Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3 #> 5    Hornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3 #> 6              Valiant 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3 #> 7           Duster 360 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3 #> 8            Merc 240D 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4 #> 9             Merc 230 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4 #> 10            Merc 280 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4 #> 11           Merc 280C 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4 #> 12          Merc 450SE 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3 #> 13          Merc 450SL 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3 #> 14         Merc 450SLC 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3 #> 15  Cadillac Fleetwood 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3 #> 16 Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3 #> 17   Chrysler Imperial 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3 #> 18            Fiat 128 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4 #> 19         Honda Civic 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4 #> 20      Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4 #> 21       Toyota Corona 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3 #> 22    Dodge Challenger 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3 #> 23         AMC Javelin 15.2   8 304.0 150 3.15 3.435 17.30  0  0    3 #> 24          Camaro Z28 13.3   8 350.0 245 3.73 3.840 15.41  0  0    3 #> 25    Pontiac Firebird 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3 #> 26           Fiat X1-9 27.3   4  79.0  66 4.08 1.935 18.90  1  1    4 #> 27       Porsche 914-2 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5 #> 28        Lotus Europa 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5 #> 29      Ford Pantera L 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5 #> 30        Ferrari Dino 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5 #> 31       Maserati Bora 15.0   8 301.0 335 3.54 3.570 14.60  0  1    5 #> 32          Volvo 142E 21.4   4 121.0 109 4.11 2.780 18.60  1  1    4 #>    carb #> 1     4 #> 2     4 #> 3     1 #> 4     1 #> 5     2 #> 6     1 #> 7     4 #> 8     2 #> 9     2 #> 10    4 #> 11    4 #> 12    3 #> 13    3 #> 14    3 #> 15    4 #> 16    4 #> 17    4 #> 18    1 #> 19    2 #> 20    1 #> 21    1 #> 22    2 #> 23    2 #> 24    4 #> 25    2 #> 26    1 #> 27    2 #> 28    2 #> 29    4 #> 30    6 #> 31    8 #> 32    2  # get the names of the columns in the databases's table dbListFields(pool, \"mtcars\") #>  [1] \"row_names\" \"mpg\"       \"cyl\"       \"disp\"      \"hp\"        #>  [6] \"drat\"      \"wt\"        \"qsec\"      \"vs\"        \"am\"        #> [11] \"gear\"      \"carb\"       # use dbExecute to change the \"mpg\" and \"cyl\" values of the 1st row dbExecute(pool,   paste(     \"UPDATE mtcars\",     \"SET mpg = '22.0', cyl = '10'\",     \"WHERE row_names = 'Mazda RX4'\"   ) ) #> [1] 1  # read the 1st row of \"mtcars\" table to confirm the previous change dbGetQuery(pool, \"SELECT * FROM mtcars WHERE row_names = 'Mazda RX4'\") #>   row_names mpg cyl disp  hp drat   wt  qsec vs am gear carb #> 1 Mazda RX4  22  10  160 110  3.9 2.62 16.46  0  1    4    4  # drop the \"mtcars\" table from the database dbRemoveTable(pool, \"mtcars\")  # list the current tables in the database dbListTables(pool) #> character(0)  poolClose(pool)"},{"path":"http://rstudio.github.io/pool/reference/Pool-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a pool of reusable objects — Pool-class","title":"Create a pool of reusable objects — Pool-class","text":"generic pool class holds objects. can fetched pool released back , little computational cost. pool created closed longer needed, prevent leaks. See dbPool() example object pooling applied DBI database connections.","code":""},{"path":"http://rstudio.github.io/pool/reference/Pool-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a pool of reusable objects — Pool-class","text":"","code":"poolCreate(   factory,   minSize = 1,   maxSize = Inf,   idleTimeout = 60,   validationInterval = 600,   state = NULL )  poolClose(pool)  # S4 method for Pool poolClose(pool)"},{"path":"http://rstudio.github.io/pool/reference/Pool-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a pool of reusable objects — Pool-class","text":"factory factory function used create responsible generation objects pool hold (ex: DBI database connections, function dbConnect). must take arguments. minSize, maxSize minimum maximum number objects pool. idleTimeout number seconds idle object kept pool destroyed (applies number objects minSize). Use Inf want created objects never destroyed (great reason usually). validationInterval minimum number seconds pool wait running validation check next checked object. necessarily validating every checked object, can substantial performance gains (especially interval checking new objects small). state pool public variable used backend authors necessary. pool Pool object previously created poolCreate","code":""},{"path":"http://rstudio.github.io/pool/reference/dbPool.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a pool of database connections — dbPool","title":"Create a pool of database connections — dbPool","text":"dbPool() drop-replacement DBI::dbConnect() provides shared pool connections can automatically reconnect database needed.","code":""},{"path":"http://rstudio.github.io/pool/reference/dbPool.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a pool of database connections — dbPool","text":"","code":"dbPool(   drv,   ...,   minSize = 1,   maxSize = Inf,   onCreate = NULL,   idleTimeout = 60,   validationInterval = 600,   validateQuery = NULL )"},{"path":"http://rstudio.github.io/pool/reference/dbPool.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a pool of database connections — dbPool","text":"drv DBI Driver, e.g. RSQLite::SQLite(), RPostgres::Postgres(), odbc::odbc() etc. ... Arguments passed DBI::dbConnect(). used identify database provide needed authentication. minSize, maxSize minimum maximum number objects pool. onCreate function takes single argument, connection, called connection created. Use DBI::dbExecute() set default options every connection created pool. idleTimeout number seconds idle object kept pool destroyed (applies number objects minSize). Use Inf want created objects never destroyed (great reason usually). validationInterval minimum number seconds pool wait running validation check next checked object. necessarily validating every checked object, can substantial performance gains (especially interval checking new objects small). validateQuery simple query can used verify connetction valid. provided, dbPool() try common options, work databases.","code":""},{"path":"http://rstudio.github.io/pool/reference/dbPool.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a pool of database connections — dbPool","text":"","code":"# You use a dbPool in the same way as a standard DBI connection pool <- dbPool(RSQLite::SQLite()) pool #> <Pool> of SQLiteConnection objects #>   Objects checked out: 0 #>   Available in pool: 1 #>   Max size: Inf #>   Valid: TRUE  DBI::dbWriteTable(pool, \"mtcars\", mtcars) dbGetQuery(pool, \"SELECT * FROM mtcars LIMIT 4\") #>    mpg cyl disp  hp drat    wt  qsec vs am gear carb #> 1 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 #> 2 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 #> 3 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 #> 4 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1  # Always close a pool when you're done using it poolClose(pool)  # Using the RMySQL package if (requireNamespace(\"RMySQL\", quietly = TRUE)) {   pool <- dbPool(     drv = RMySQL::MySQL(),     dbname = \"shinydemo\",     host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",     username = \"guest\",     password = \"guest\"   )    dbGetQuery(pool, \"SELECT * from City LIMIT 5;\")    poolClose(pool) }"},{"path":"http://rstudio.github.io/pool/reference/hooks.html","id":null,"dir":"Reference","previous_headings":"","what":"Pooled object methods. — hooks","title":"Pooled object methods. — hooks","text":"backend authors . Authors implement , called Pool class methods. called directly either backend authors end users.","code":""},{"path":"http://rstudio.github.io/pool/reference/hooks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pooled object methods. — hooks","text":"","code":"onActivate(object)  onPassivate(object)  onDestroy(object)  onValidate(object, query)  # S4 method for ANY onActivate(object)  # S4 method for ANY onPassivate(object)  # S4 method for ANY onDestroy(object)  # S4 method for ANY onValidate(object, query)  # S4 method for DBIConnection onPassivate(object)  # S4 method for DBIConnection onDestroy(object)  # S4 method for DBIConnection onValidate(object)"},{"path":"http://rstudio.github.io/pool/reference/hooks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pooled object methods. — hooks","text":"object pooled object. query simple query can used verify object functions expected.","code":""},{"path":"http://rstudio.github.io/pool/reference/pool-package.html","id":null,"dir":"Reference","previous_headings":"","what":"pool: Object Pooling — pool-package","title":"pool: Object Pooling — pool-package","text":"Enables creation object pools, make less computationally expensive fetch new object. Currently supported pooled objects 'DBI' connections.","code":""},{"path":[]},{"path":"http://rstudio.github.io/pool/reference/pool-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"pool: Object Pooling — pool-package","text":"Maintainer: Hadley Wickham hadley@posit.co Authors: Joe Cheng joe@posit.co Barbara Borges contributors: Posit Software, PBC [copyright holder, funder]","code":""},{"path":"http://rstudio.github.io/pool/reference/poolCheckout.html","id":null,"dir":"Reference","previous_headings":"","what":"Check out and return object from the pool — poolCheckout","title":"Check out and return object from the pool — poolCheckout","text":"Use poolCheckout() check object pool poolReturn() return . receive warning objects returned pool closed. localCheckout() convenience function can used inside functions (function-scoped operations like shiny::reactive() local()). checks object automatically returns function exits Note validation performed object checked , generally want keep checked around little time possible.","code":""},{"path":"http://rstudio.github.io/pool/reference/poolCheckout.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check out and return object from the pool — poolCheckout","text":"","code":"poolCheckout(pool)  # S4 method for Pool poolCheckout(pool)  poolReturn(object)  # S4 method for ANY poolReturn(object)  localCheckout(pool, env = parent.frame())"},{"path":"http://rstudio.github.io/pool/reference/poolCheckout.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check out and return object from the pool — poolCheckout","text":"pool pool get object . object Object return env Environment corresponding execution frame. expert use .","code":""},{"path":"http://rstudio.github.io/pool/reference/poolCheckout.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check out and return object from the pool — poolCheckout","text":"","code":"pool <- dbPool(RSQLite::SQLite()) con <- poolCheckout(pool) con #> <SQLiteConnection> #>   Path:  #>   Extensions: TRUE poolReturn(con)  f <- function() {   con <- localCheckout(pool)   # do something ... } f()  poolClose(pool)"},{"path":"http://rstudio.github.io/pool/reference/poolWithTransaction.html","id":null,"dir":"Reference","previous_headings":"","what":"Self-contained database transactions using pool — poolWithTransaction","title":"Self-contained database transactions using pool — poolWithTransaction","text":"function allows use pool object directly execute transaction database connection, without ever actually check connection pool return . Using function instead direct transaction methods guarantee leak connections forget commit/rollback transaction.","code":""},{"path":"http://rstudio.github.io/pool/reference/poolWithTransaction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Self-contained database transactions using pool — poolWithTransaction","text":"","code":"poolWithTransaction(pool, func)"},{"path":"http://rstudio.github.io/pool/reference/poolWithTransaction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Self-contained database transactions using pool — poolWithTransaction","text":"pool pool object fetch connection . func function one argument, conn (database connection checked pool).","code":""},{"path":"http://rstudio.github.io/pool/reference/poolWithTransaction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Self-contained database transactions using pool — poolWithTransaction","text":"func's return value.","code":""},{"path":"http://rstudio.github.io/pool/reference/poolWithTransaction.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Self-contained database transactions using pool — poolWithTransaction","text":"function similar DBI::dbWithTransaction(), arguments work little differently. First, takes pool object, instead connection. Second, instead taking arbitrary chunk code execute transaction (.e. either run commands successfully run ), takes function. function (func argument) gives argument use body, database connection. , can use connection methods without ever check connection. can also use arbitrary R code inside func's body. function called fetch connection pool. function returns, release connection back pool. Like DBI sister DBI::dbWithTransaction(), function calls dbBegin() executing code, dbCommit() successful completion, dbRollback() case error. means calling poolWithTransaction always side effects, namely commit roll back code executed func called. addition, modify local R environment within func (e.g. setting global variables, writing disk), changes persist function returned. Also, like DBI::dbWithTransaction(), also special function called dbBreak() allows early, silent exit rollback. can called inside poolWithTransaction.","code":""},{"path":"http://rstudio.github.io/pool/reference/poolWithTransaction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Self-contained database transactions using pool — poolWithTransaction","text":"","code":"if (requireNamespace(\"RSQLite\", quietly = TRUE)) {   pool <- dbPool(RSQLite::SQLite(), dbname = \":memory:\")    dbWriteTable(pool, \"cars\", head(cars, 3))   dbReadTable(pool, \"cars\")   # there are 3 rows    ## successful transaction   poolWithTransaction(pool, function(conn) {     dbExecute(conn, \"INSERT INTO cars (speed, dist) VALUES (1, 1);\")     dbExecute(conn, \"INSERT INTO cars (speed, dist) VALUES (2, 2);\")     dbExecute(conn, \"INSERT INTO cars (speed, dist) VALUES (3, 3);\")   })   dbReadTable(pool, \"cars\")   # there are now 6 rows    ## failed transaction -- note the missing comma   tryCatch(     poolWithTransaction(pool, function(conn) {       dbExecute(conn, \"INSERT INTO cars (speed, dist) VALUES (1, 1);\")       dbExecute(conn, \"INSERT INTO cars (speed dist) VALUES (2, 2);\")       dbExecute(conn, \"INSERT INTO cars (speed, dist) VALUES (3, 3);\")     }),     error = identity   )   dbReadTable(pool, \"cars\")   # still 6 rows    ## early exit, silently   poolWithTransaction(pool, function(conn) {     dbExecute(conn, \"INSERT INTO cars (speed, dist) VALUES (1, 1);\")     dbExecute(conn, \"INSERT INTO cars (speed, dist) VALUES (2, 2);\")     if (nrow(dbReadTable(conn, \"cars\")) > 7) dbBreak()     dbExecute(conn, \"INSERT INTO cars (speed, dist) VALUES (3, 3);\")   })   dbReadTable(pool, \"cars\")   # still 6 rows    poolClose(pool)  } else {   message(\"Please install the 'RSQLite' package to run this example\") }"},{"path":"http://rstudio.github.io/pool/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. DBI dbBreak","code":""},{"path":"http://rstudio.github.io/pool/reference/tbl.Pool.html","id":null,"dir":"Reference","previous_headings":"","what":"Use pool with dbplyr — tbl.Pool","title":"Use pool with dbplyr — tbl.Pool","text":"Wrappers key dplyr (dbplyr) methods pool works seemlessly dbplyr.","code":""},{"path":"http://rstudio.github.io/pool/reference/tbl.Pool.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use pool with dbplyr — tbl.Pool","text":"","code":"tbl.Pool(src, from, ..., vars = NULL)  copy_to.Pool(   dest,   df,   name = deparse(substitute(df)),   overwrite = FALSE,   temporary = TRUE,   ... )"},{"path":"http://rstudio.github.io/pool/reference/tbl.Pool.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use pool with dbplyr — tbl.Pool","text":"src, dest dbPool. Name table dbplyr::sql() string. ... arguments passed individual methods vars character vector variable names src. expert use . df local data frame, tbl_sql source, tbl_sql another source. another source, data must transition R one pass, suitable transferring small amounts data. name name new remote table. overwrite TRUE, overwrite existing table name name. FALSE, throw error name already exists. temporary TRUE, create temporary table local connection automatically deleted connection expires","code":""},{"path":"http://rstudio.github.io/pool/reference/tbl.Pool.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use pool with dbplyr — tbl.Pool","text":"","code":"library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union  pool <- dbPool(RSQLite::SQLite()) # copy a table into the database copy_to(pool, mtcars, \"mtcars\", temporary = FALSE)  # retrieve a table mtcars_db <- tbl(pool, \"mtcars\") mtcars_db #> # Source:   table<mtcars> [?? x 11] #> # Database: sqlite 3.40.0 [] #>      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb #>    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #>  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4 #>  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4 #>  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1 #>  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1 #>  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2 #>  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1 #>  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4 #>  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2 #>  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2 #> 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4 #> # … with more rows mtcars_db %>% select(mpg, cyl, disp) #> # Source:   SQL [?? x 3] #> # Database: sqlite 3.40.0 [] #>      mpg   cyl  disp #>    <dbl> <dbl> <dbl> #>  1  21       6  160  #>  2  21       6  160  #>  3  22.8     4  108  #>  4  21.4     6  258  #>  5  18.7     8  360  #>  6  18.1     6  225  #>  7  14.3     8  360  #>  8  24.4     4  147. #>  9  22.8     4  141. #> 10  19.2     6  168. #> # … with more rows mtcars_db %>% filter(cyl == 6) %>% collect() #> # A tibble: 7 × 11 #>     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb #>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4 #> 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4 #> 3  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1 #> 4  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1 #> 5  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4 #> 6  17.8     6  168.   123  3.92  3.44  18.9     1     0     4     4 #> 7  19.7     6  145    175  3.62  2.77  15.5     0     1     5     6  poolClose(pool)"},{"path":"http://rstudio.github.io/pool/news/index.html","id":"pool-development-version","dir":"Changelog","previous_headings":"","what":"pool (development version)","title":"pool (development version)","text":"Pool re-licensed MIT (#158). dbPool() gains onCreate parameter allows something every connection pool creates. useful setting options want apply every connection (#98). New localCheckout() checkouts automatically returns object. works function scope. Pools now get useful print method (#140). dbPool()’s validateQuery now actually used (#153). Connections now validated first checkout ensure connection validation strategy ok. DBI methods dispatch correctly cases; particular dbReadTable() friends now work correctly used DBI::Id() (#120). pool now implements dbplyr 2.0.0 interface, eliminating warnings using pool dplyr (#132). Pool errors warnings reviewed eye making immediately actionable (#145). Added support SAP HANA databases (@marcosci, #103).","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"pool-016","dir":"Changelog","previous_headings":"","what":"pool 0.1.6","title":"pool 0.1.6","text":"CRAN release: 2021-01-14 left_join() friends work pool objects (#111). dbPool() objects previously leak memory. (#115)","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"pool-015","dir":"Changelog","previous_headings":"","what":"pool 0.1.5","title":"pool 0.1.5","text":"CRAN release: 2020-11-03 dplyr dbplyr now Suggests instead Imports. Thanks, @AkhilGNair! (#106) used dbplyr, tbls now store copy pool, checked connection. (#107) dbListObjects(), dbCreateTable(), dbAppendTable(), dbIsReadOnly(), dbQuoteLiteral(), dbUnquoteIdentifier() methods now implemented pool objects. (#100, #109)","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"pool-0143","dir":"Changelog","previous_headings":"","what":"pool 0.1.4.3","title":"pool 0.1.4.3","text":"CRAN release: 2019-10-03 Previously, pool always set options(warn=1) running tasks. now ensures value warn can 1 greater. can useful debugging, options(warn=2) can used. (#90)","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"pool-0142","dir":"Changelog","previous_headings":"","what":"pool 0.1.4.2","title":"pool 0.1.4.2","text":"CRAN release: 2019-01-07 Update unit test compatibility future dbplyr. (#82)","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"pool-0141","dir":"Changelog","previous_headings":"","what":"pool 0.1.4.1","title":"pool 0.1.4.1","text":"CRAN release: 2018-06-29 Change package maintainer","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"pool-014","dir":"Changelog","previous_headings":"","what":"pool 0.1.4","title":"pool 0.1.4","text":"CRAN release: 2018-03-10 Changed methods dbExistsTable(), dbRemoveTable(), dbWriteTable(), dbGetQuery(), dbExecute(), dbListFields() dbReadTable() dispatch first two arguments, per default definition DBI. (#57)","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"pool-013","dir":"Changelog","previous_headings":"","what":"pool 0.1.3","title":"pool 0.1.3","text":"CRAN release: 2017-11-03 Use requireNamespace(\"pkg\", quietly = TRUE) RMySQL RSQLite examples tests since “Suggests” packages (.e. “Depends”). (commit 4205feb)","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"pool-012","dir":"Changelog","previous_headings":"","what":"pool 0.1.2","title":"pool 0.1.2","text":"CRAN release: 2017-11-03","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"minor-new-features-and-improvements-0-1-2","dir":"Changelog","previous_headings":"","what":"Minor new features and improvements","title":"pool 0.1.2","text":"Included examples documentation. (#50) Fixed “test-create-destroy.R” test. Previously, test run manually uses later async nature captured testthat. However, using later::run_now() immediately relevant code snippet (.e. still inside first argument expect_*) solves issue. (#50) Use difftime(t1, t0, units = \"secs\") calculating time interval. Unlike simpler t1 - t0 method, guarantees result always consistently number seconds. However, ’s change calculating new time (time interval) using t2 <- t1 - interval, since want t2 time, rather time interval (always returned difftime). (#50 #48, thank @caewok!)","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"bug-fixes-0-1-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"pool 0.1.2","text":"Fix dbplyr wrapper functions weren’t passing additional arguments call original dbplyr function included ... = ... instead .... Also, pass temporary = temporary copy_to.Pool, don’t defeat whole purpose wrapper. (#50) Change place check maximum number objects made. Previously, chunk code misplaced result buggy behavior: namely, maximum number objects reached, objects checked (even returned /objects back pool). reason wasn’t spotted earlier default maxSize Inf (’s usually good reason change ). (#50)","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"pool-011","dir":"Changelog","previous_headings":"","what":"pool 0.1.1","title":"pool 0.1.1","text":"CRAN release: 2017-09-23","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"breaking-changes-0-1-1","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"pool 0.1.1","text":"Fix #39: Moved dplyr support pool dplyr 0.5.0 dplyr 0.7.0, includes lot breaking changes including addition brand new package called dbplyr. (#42) pool users, main change src_* functions now gone (dplyr pool). Therefore, something like: can just change simpler: ’re still old version dplyr want use pool well, please install package using tag created purpose: Changed time arguments accept number seconds, instead milliseconds. later package uses reason pool different, except backward compatibility. Since time arguments dbPool (idleTimeout validationInterval) default values, ’re hoping change won’t even noticed users. setting either directly, however, need update app update pool package. (#44) Dropped Pool methods around dbConnect dbDisconnect, made easier lose track whether ’re operating Pool object database connection directly. now , allow get connection pool return back, respectively: (#44)","code":"data <- src_pool(pool) %>% tbl(\"test\") data <- pool %>% tbl(\"test\") devtools::install_github(\"rstudio/pool@dplyr-pre-0.7.0-compat\") con <- poolCheckout(pool) poolReturn(con)"},{"path":"http://rstudio.github.io/pool/news/index.html","id":"new-features-0-1-1","dir":"Changelog","previous_headings":"","what":"New features","title":"pool 0.1.1","text":"Use later package scheduling tasks (#44). also side effect fixing #40 #43 since later allows us get rid naiveScheduler completely.","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"library-updates-0-1-1","dir":"Changelog","previous_headings":"","what":"Library updates","title":"pool 0.1.1","text":"Roxygen 5.0.1 6.0.1. (commit #9952000)","code":""},{"path":"http://rstudio.github.io/pool/news/index.html","id":"pool-010","dir":"Changelog","previous_headings":"","what":"pool 0.1.0","title":"pool 0.1.0","text":"Initial release!","code":""}]
